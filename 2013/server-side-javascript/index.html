<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>server side Javascript - Ist Javascript eine ernstzunehmende Alternative?</title>

        <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
        <meta name="author" content="Hakim El Hattab">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <link rel="stylesheet" href="css/reveal.min.css">
        <link rel="stylesheet" href="css/theme/sky.css" id="theme">

        <!-- For syntax highlighting -->
        <link rel="stylesheet" href="lib/css/tomorrow-night-eighties.css">

        <!-- If the query includes 'print-pdf', use the PDF print sheet -->
        <script>
            document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">

                <section data-markdown>
                    <script type="text/template">
                        ## Server side Javascript

                        Von [Daniel S. Reichenbach](http://marenkay.com) / [@marenkay](http://twitter.com/marenkay)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Achtung

                        Wir entwickeln mit PHP, Ruby, Java, .NET und zahlreichen Frameworks und &quot;sprechen&quot;
                        alle Javascript zur Umsetzung von Frontends für Web-Anwendungen.

                        Ist Javascript eine Alternative?
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Wer bin ich

                        Vater, Entwickler, Nerd

                        C/C++, PHP, Ruby, Python ...

                        [github.com/danielsreichenbach](http://github.com/danielsreichenbach)
                        [twitter.com/marenkay](http://twitter.com/marenkay)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Was wir haben

                        Seit 20 Jahren liefern wir Webseiten mit Apache, IIS, nginx,
                        Unicorn, u.a. stateless aus.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Was wir haben

                        1 - **n** Server stellen einen limitierten Pool an Threads und Verbindungen bereit
                        und verbrauchen je nach Umgebung Speicher und Leistung.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Was wir haben

                        Bei steigenden Anfragen erzeugen wir Wartezeiten oder müssen das **n** vergrößeren
                        und Load Balancing u./o. Proxying betreiben.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Ein Beispiel

                        Ein Apache Thread verbraucht ~ 400-500MB Speicher und hält ~ 200 Verbindungen.

                        Ein PHP Prozess verbraucht je nach Konfiguration Speicher und wird für
                        jede Verbindung instanziert.

                        Damit fahren wir mit 16GB RAM ca. 4000 Verbindungen.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Ein Beispiel

                        Aber: wohin mit Datenbanken und anderen Diensten?
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Geht das besser?

                        Nehmen wir nginx statt Apache.

                        nginx nutzt ein anderes Modell, ein Hauptprozess und Worker Prozesse, die bei Bedarf event-basiert erzeugt werden.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Geht das besser?

                        Bei 2.5MB Speicher kann nginx 10k gleichzeitige Anfragen verarbeiten. Für Apache
                        hätten wir 64B verbaut.

                        Merke: Prozesse sind günstiger als Threads! Was in Threads läuft, blockiert die
                        weitere Verarbeitung und kommt mit einem Delta.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Geht das besser?

                        ![Memory usage and concurren requests](./img/nginx-apache-memory.png)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Geht das besser?

                        ![Requests per second](./img/nginx-apache-reqs-sec.png)
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Der Unterschied

                        Die Apache Leistung sinkt mit steigender Anzahl von gleichzeitigen Verbindungen,
                        ergo müssten wir skalieren mit zusätzlicher Hardware und mehr Verbindungen pro Thread.

                        nginx läuft bei gleichbleibendem Speicherbedarf und verzichtet auf Overhead.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Und PHP und Co?

                        Laufen bei nginx als Prozess im Hintergrund, werden einmal instanziert und
                        für jede Verbindung wieder verwertet.

                        Daher: nicht pro Verbindung ein Prozess.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Gibt es Alternativen?

                        Was wir kennen ist stateless, was wir wollen ist Echtzeit, statefull.

                        Aber halt... war da nicht noch Javascript und "sprechen" das nicht alle Entwickler?

                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Node.js

                        V8 Javascript engine, die JS in nativen Bytecode übersetzt.

                        Mit Heuristik, cache und co holt man hier Performance raus.

                        Javascript wird in einer event-basierten engine bereitgestellt.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Node.js

                        Web sockets erlauben real time Verbindungen

                        Non-blocking I/O. Rein, hop, und weg! I/O kostet Zeit.

                        Von 3 CPU Zyklen im L1 Cache zu 41 Mio. Zyklen bei Disks bis zu 240 Mio.
                        Zyklen über Netzwerk.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Node.js

                        Ein Thread läuft, fragt nach neuen Events und führt diese direkt aus.

                        Klasse, weil ~ 1MB Speicher drauf geht.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Ein Thread und IO?

                        Wenn ein Event nach IO intensiver Arbeit verlangt, verlangsamt sich das abrufen
                        neuer Events, den Events müssen abgeschlossen werden.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Ein Thread und eine Exception

                        Fehler in Skripten werden gefährlich.

                        Warum? Jede Exception muss gefangen und behandelt werden.

                        Sonst? Kann im schlimmsten Fall der Node.js Prozess sterben.

                    </script>
                </section>

                <section>
                    <section data-markdown>
                        <script type="text/template">
                            ## Beispiel

                                var fs = require('fs');

                                fs.readFile('somefile.txt', function (err, data) {
                                  if (err) throw err;
                                  console.log(data);
                                });

                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                            ## Ergebnis

                                Error: ENOENT, open 'somefile.txt'

                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                            ## Besser

                                var domain = require('domain');
                                var d = domain.create();
                                var fs = require('fs');

                                d.on('error', function(err) {
                                  console.error(err);
                                });

                                d.run(function() {
                                  fs.readFile('somefile.txt', function (err, data) {
                                    if (err) throw err;
                                    console.log(data);
                                  });
                                });

                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                            ## Die Lösung?

                            In jedem Fall gilt: Crashes sollte man absichtlich provozieren für jedes
                            erdenkliche Problem und abfangen.

                            Im schlimmsten Fall gilt: Node.js überwachen und ggf. neu starten.
                        </script>
                    </section>

                    <section data-markdown>
                        <script type="text/template">
                            ## Testen, testen, testen

                            Was hilft? Unit Tests!

                            * node-unit: [https://github.com/caolan/nodeunit](https://github.com/caolan/nodeunit)
                            * Mocha: [http://visionmedia.github.io/mocha/](http://visionmedia.github.io/mocha/)
                        </script>
                    </section>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Ein Schritt zurück

                        In der "alten" Welt haben wir unsere Software Stacks:

                        * Apache, PHP, MySQL
                        * Ruby, Rails, Unicorn
                        * Java, JSP, Apache
                        * Python, Django, Apache

                        * nginx, varnish, squid

                        Was macht Node.js?
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Node Packaged Modules

                        npmjs.org verwaltet alle Module. Was PEAR, gem und pip leisten, vereint NPM

                        ~ 45k und steigende Anzahl von Modulen
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Node Packaged Modules

                        NodeJS API ist nicht stabil, keine Version 1.0 erreicht und für mindestens ein
                        Jahr wird das auch so bleiben.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Node Packaged Modules

                        Das heißt: wir wollen Features aus der Node.js API, also müssen die Module die
                        wir einsetzen mit der Node.js Entwicklung Schritt halten.
                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## Node Packaged Modules

                        Das ist nicht immer so, nur bekannte, populäre Module schaffen das.

                        Viele Module sind one man shows und schnell inkompatibel mit neuen Node.js
                        Versionen.

                    </script>
                </section>

                <section data-markdown>
                    <script type="text/template">
                        ## FIN

                        VON Daniel S. Reichenbach / marenkay.com
                    </script>
                </section>

            </div>

        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.min.js"></script>

        <script>

            // Full list of configuration options available here:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
                transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
                    // { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
                    // { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
                ]
            });

        </script>

    </body>
</html>
